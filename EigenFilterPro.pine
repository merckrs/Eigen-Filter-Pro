// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© Merckrs
//
// -----------------------------------------------------------------------------
// EIGEN-FILTER PRO: INSTITUTIONAL RISK MODEL (MP EDITION)
// -----------------------------------------------------------------------------
// ðŸ§  Scientific Update (v2.0):
// This version integrates the "Marchenko-Pastur Law" (MP Law).
// It calculates a theoretical "Noise Ceiling" to distinguish between
// random market noise and genuine systemic risk signals.
// Signals below the MP threshold are filtered out.
//
// ðŸ’¡ THIS PROJECT IS OPEN SOURCE AND FREE.
// -----------------------------------------------------------------------------

//@version=5
indicator("Matrix Eigen-Filter Pro [MP Noise Filter]", shorttitle="Eigen-Risk MP", overlay=false)

// --- 1. SETTINGS ---
group_asset = "Asset Configuration"
ticker2_input = input.symbol("CRYPTOCAP:TOTAL2", "Benchmark Asset (Market)", group=group_asset, tooltip="For Crypto Analysis, CRYPTOCAP:TOTAL2 is recommended. For Stocks, use SPY or QQQ.")
length = input.int(30, "Analysis Window (Days)", minval=10, group=group_asset)

group_math = "Sensitivity & Filters"
use_mp_filter = input.bool(true, "Marchenko-Pastur Noise Filter", group=group_math, tooltip="If enabled, removes signals caused by random market noise based on RMT.")
use_zscore = input.bool(true, "Dynamic Threshold (Z-Score)", group=group_math)
z_lookback = input.int(200, "Historical Memory (Days)", group=group_math)
z_threshold = input.float(2.0, "Crisis Trigger (Sigma)", group=group_math)
smooth_len = input.int(3, "Signal Smoothing", group=group_math)

// --- 2. CALCULATION ENGINE ---
price1 = close
price2 = request.security(ticker2_input, timeframe.period, close)

// Logarithmic Returns
ret1 = math.log(price1 / price1[1])
ret2 = math.log(price2 / price2[1])

// Statistics
mean1 = ta.sma(ret1, length)
mean2 = ta.sma(ret2, length)
var1 = ta.sma(math.pow(ret1 - mean1, 2), length)
var2 = ta.sma(math.pow(ret2 - mean2, 2), length)
cov12 = ta.sma((ret1 - mean1) * (ret2 - mean2), length)

// Eigenvalues of Covariance Matrix (Original Risk Score)
trace = var1 + var2
det = (var1 * var2) - (cov12 * cov12)
delta = (trace * trace) - (4 * det)
lambda1 = (trace + math.sqrt(math.max(delta, 0))) / 2
lambda2 = (trace - math.sqrt(math.max(delta, 0))) / 2

// Raw Risk Score
raw_risk = (lambda2 > 0) ? (lambda1 / lambda2) : 0

// --- 3. MARCHENKO-PASTUR FILTER (SCIENTIFIC ADDITION) ---
// Checks if the signal is "Coincidence" or "Real Structure".

// A. Normalized Correlation Coefficient
// MP law applies to Correlation matrices, so we normalize Covariance.
std1 = math.sqrt(var1)
std2 = math.sqrt(var2)
correlation = (std1 * std2 != 0) ? (cov12 / (std1 * std2)) : 0

// B. Theoretical Noise Ceiling (Lambda Max)
// Formula: (1 + sqrt(N/T))^2
// N = 2 (Two assets), T = length
q = length / 2.0 // Q = T/N
mp_noise_ceiling = math.pow(1 + math.sqrt(1/q), 2)

// C. Our Dominant Eigenvalue
// For 2x2 Correlation matrix, dominant eigenvalue = 1 + |correlation|
eigen_corr_dominant = 1 + math.abs(correlation)

// D. FILTER DECISION
// If our eigenvalue is smaller than the theoretical noise ceiling, it's just noise.
is_noise = use_mp_filter ? (eigen_corr_dominant < mp_noise_ceiling) : false

// If noise, silence the risk (set to 0); otherwise use raw risk.
filtered_risk = is_noise ? 0 : raw_risk

// --- 4. VISUALIZATION ---
smoothed_risk = ta.sma(filtered_risk, smooth_len)

risk_mean = ta.sma(smoothed_risk, z_lookback)
risk_std = ta.stdev(smoothed_risk, z_lookback)
z_score = (smoothed_risk - risk_mean) / (risk_std + 0.00001)

final_metric = use_zscore ? z_score : smoothed_risk
threshold_val = use_zscore ? z_threshold : 30.0

// Visualization Logic
risk_color = final_metric > threshold_val ? color.new(#9c27b0, 0) : final_metric > (threshold_val * 0.5) ? color.new(#ff9800, 0) : color.new(#2196f3, 0)

// If MP filter silenced the signal, show it as gray/flat
is_silenced = (final_metric == 0) or (use_zscore and final_metric < 0.1)
plot_color = is_silenced ? color.gray : risk_color

p1 = plot(final_metric, "Systemic Risk Score", color=plot_color, linewidth=2)
p2 = plot(use_zscore ? 0 : 1, "Baseline", color=color.gray, display=display.none)
fill(p1, p2, color=color.new(risk_color, 75), title="Risk Density")
hline(threshold_val, "CRISIS THRESHOLD", color=color.red, linestyle=hline.style_dashed)
barcolor(final_metric > threshold_val ? color.rgb(116, 116, 116) : na, title="Zombie Candles")
